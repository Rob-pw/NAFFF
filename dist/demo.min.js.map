{"version":3,"sources":["webpack:///webpack/bootstrap c28cc70b926efd8291db","webpack:///./~/meld/meld.js","webpack:///./src/demo.js","webpack:///(webpack)/buildin/amd-define.js"],"names":["events","on","emit","components","record","args","evented","targetName","target","methodNames","Object","getOwnPropertyNames","prototype","forEach","methodName","before","info","TodoList","todo","items","push","length","TodoItem","text","value","todoList","add"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,oCAAoC;;AAEvE;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,6BAA6B;AACzC,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,eAAe,mBAAmB,UAAU;AAC5C,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,qCAAqC;AAC5E;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,uBAAuB,OAAO;AAC9B,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,mBAAmB,OAAO;AAC1B,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B,mBAAmB,OAAO;AAC1B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,UAAU;;AAErD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD,GAAG,YAAY;AACf;;AAEA;;AAEA,CAAC;AAAA;AACD,CAAC,wBAAuG;AACxG;;;;;;;;;;;;;;kQCrlBA;;;AACA;;;;;;;;;;;;AAEA,IAAMA,SAAS,EAAEC,IAAI,cAAM,CAAE,CAAd,EAAgBC,MAAM,gBAAM,CAAE,CAA9B,EAAf,C,CAAiD;AACjD,IAAMC,aAAa,EAAnB;;AAEA,SAASC,MAAT,GAAyB;AAAA,oCAANC,IAAM;AAANA,QAAM;AAAA;;AACvBL,SAAOE,IAAP,gBAAY,KAAZ,SAAsBG,IAAtB;AACD;;AAED,SAASC,OAAT,CAAiBC,UAAjB,EAA6B;AAC3B,SAAO,UAACC,MAAD,EAAY;AACjBL,eAAWI,UAAX,IAAyBC,MAAzB;;AAEA,QAAMC,cAAcC,OAAOC,mBAAP,CAA2BH,OAAOI,SAAlC,CAApB;;AAEAH,gBAAYI,OAAZ,CAAoB,UAACC,UAAD,EAAgB;AAClC,qBAAKC,MAAL,CAAYP,OAAOI,SAAnB,EAA8BE,UAA9B,EAA0C,YAAa;AAAA,2CAATT,IAAS;AAATA,cAAS;AAAA;;AACrDD,eAAOI,MAAP,EAAeD,UAAf,EAA2BO,UAA3B,eACKT,IADL;AAGD,OAJD;AAKD,KAND;;AAQA;AAAA;;AACE,wBAAqB;AAAA;;AAAA,2CAANA,IAAM;AAANA,cAAM;AAAA;;AACnBD,eAAOI,MAAP,EAAeD,UAAf,eACKF,IADL;;AADmB;AAMpB;;AAPH;AAAA,MAAqBG,MAArB;AASD,GAtBD;AAuBD;;AAEDR,OAAOC,EAAP,CAAU,KAAV,EAAiB,YAAa;AAAA;;AAC5B,uBAAQe,IAAR;AACD,CAFD;;IAKMC,Q,WADLX,QAAQ,UAAR,C;;;;;;;aAES;;;;;;wBAEJY,I,EAAM;AACR,WAAKC,KAAL,CAAWC,IAAX,CAAgBF,IAAhB;AACA,aAAOA,IAAP;AACD;;;4BAEO;AACN,aAAO,KAAKC,KAAL,CAAWE,MAAlB;AACD;;;;;IAIGC,Q,YADLhB,QAAQ,UAAR,C;;;;;;;yBAEMiB,I,EAAM;AACT,WAAKC,KAAL,GAAaD,IAAb;AACD;;;;;;;AAGH,CAAC,YAAM;AACL,MAAME,WAAW,IAAIR,QAAJ,EAAjB;AACA,MAAMC,OAAO,IAAII,QAAJ,CAAa,iBAAb,CAAb;;AAEAG,WAASC,GAAT,CAAaR,IAAb;AACD,CALD,I;;;;;;AC7DA;AACA;AACA","file":"demo.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c28cc70b926efd8291db","/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * meld\n * Aspect Oriented Programming for Javascript\n *\n * meld is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 1.3.1\n */\n(function (define) {\ndefine(function () {\n\n\t//\n\t// Public API\n\t//\n\n\t// Add a single, specific type of advice\n\t// returns a function that will remove the newly-added advice\n\tmeld.before =         adviceApi('before');\n\tmeld.around =         adviceApi('around');\n\tmeld.on =             adviceApi('on');\n\tmeld.afterReturning = adviceApi('afterReturning');\n\tmeld.afterThrowing =  adviceApi('afterThrowing');\n\tmeld.after =          adviceApi('after');\n\n\t// Access to the current joinpoint in advices\n\tmeld.joinpoint =      joinpoint;\n\n\t// DEPRECATED: meld.add(). Use meld() instead\n\t// Returns a function that will remove the newly-added aspect\n\tmeld.add =            function() { return meld.apply(null, arguments); };\n\n\t/**\n\t * Add an aspect to all matching methods of target, or to target itself if\n\t * target is a function and no pointcut is provided.\n\t * @param {object|function} target\n\t * @param {string|array|RegExp|function} [pointcut]\n\t * @param {object} aspect\n\t * @param {function?} aspect.before\n\t * @param {function?} aspect.on\n\t * @param {function?} aspect.around\n\t * @param {function?} aspect.afterReturning\n\t * @param {function?} aspect.afterThrowing\n\t * @param {function?} aspect.after\n\t * @returns {{ remove: function }|function} if target is an object, returns a\n\t *  remover { remove: function } whose remove method will remove the added\n\t *  aspect. If target is a function, returns the newly advised function.\n\t */\n\tfunction meld(target, pointcut, aspect) {\n\t\tvar pointcutType, remove;\n\n\t\tif(arguments.length < 3) {\n\t\t\treturn addAspectToFunction(target, pointcut);\n\t\t} else {\n\t\t\tif (isArray(pointcut)) {\n\t\t\t\tremove = addAspectToAll(target, pointcut, aspect);\n\t\t\t} else {\n\t\t\t\tpointcutType = typeof pointcut;\n\n\t\t\t\tif (pointcutType === 'string') {\n\t\t\t\t\tif (typeof target[pointcut] === 'function') {\n\t\t\t\t\t\tremove = addAspectToMethod(target, pointcut, aspect);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (pointcutType === 'function') {\n\t\t\t\t\tremove = addAspectToAll(target, pointcut(target), aspect);\n\n\t\t\t\t} else {\n\t\t\t\t\tremove = addAspectToMatches(target, pointcut, aspect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn remove;\n\t\t}\n\n\t}\n\n\tfunction Advisor(target, func) {\n\n\t\tvar orig, advisor, advised;\n\n\t\tthis.target = target;\n\t\tthis.func = func;\n\t\tthis.aspects = {};\n\n\t\torig = this.orig = target[func];\n\t\tadvisor = this;\n\n\t\tadvised = this.advised = function() {\n\t\t\tvar context, joinpoint, args, callOrig, afterType;\n\n\t\t\t// If called as a constructor (i.e. using \"new\"), create a context\n\t\t\t// of the correct type, so that all advice types (including before!)\n\t\t\t// are called with the correct context.\n\t\t\tif(this instanceof advised) {\n\t\t\t\t// shamelessly derived from https://github.com/cujojs/wire/blob/c7c55fe50238ecb4afbb35f902058ab6b32beb8f/lib/component.js#L25\n\t\t\t\tcontext = objectCreate(orig.prototype);\n\t\t\t\tcallOrig = function (args) {\n\t\t\t\t\treturn applyConstructor(orig, context, args);\n\t\t\t\t};\n\n\t\t\t} else {\n\t\t\t\tcontext = this;\n\t\t\t\tcallOrig = function(args) {\n\t\t\t\t\treturn orig.apply(context, args);\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\targs = slice.call(arguments);\n\t\t\tafterType = 'afterReturning';\n\n\t\t\t// Save the previous joinpoint and set the current joinpoint\n\t\t\tjoinpoint = pushJoinpoint({\n\t\t\t\ttarget: context,\n\t\t\t\tmethod: func,\n\t\t\t\targs: args\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tadvisor._callSimpleAdvice('before', context, args);\n\n\t\t\t\ttry {\n\t\t\t\t\tjoinpoint.result = advisor._callAroundAdvice(context, func, args, callOrigAndOn);\n\t\t\t\t} catch(e) {\n\t\t\t\t\tjoinpoint.result = joinpoint.exception = e;\n\t\t\t\t\t// Switch to afterThrowing\n\t\t\t\t\tafterType = 'afterThrowing';\n\t\t\t\t}\n\n\t\t\t\targs = [joinpoint.result];\n\n\t\t\t\tcallAfter(afterType, args);\n\t\t\t\tcallAfter('after', args);\n\n\t\t\t\tif(joinpoint.exception) {\n\t\t\t\t\tthrow joinpoint.exception;\n\t\t\t\t}\n\n\t\t\t\treturn joinpoint.result;\n\n\t\t\t} finally {\n\t\t\t\t// Restore the previous joinpoint, if necessary.\n\t\t\t\tpopJoinpoint();\n\t\t\t}\n\n\t\t\tfunction callOrigAndOn(args) {\n\t\t\t\tvar result = callOrig(args);\n\t\t\t\tadvisor._callSimpleAdvice('on', context, args);\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfunction callAfter(afterType, args) {\n\t\t\t\tadvisor._callSimpleAdvice(afterType, context, args);\n\t\t\t}\n\t\t};\n\n\t\tdefineProperty(advised, '_advisor', { value: advisor, configurable: true });\n\t}\n\n\tAdvisor.prototype = {\n\n\t\t/**\n\t\t * Invoke all advice functions in the supplied context, with the supplied args\n\t\t *\n\t\t * @param adviceType\n\t\t * @param context\n\t\t * @param args\n\t\t */\n\t\t_callSimpleAdvice: function(adviceType, context, args) {\n\n\t\t\t// before advice runs LIFO, from most-recently added to least-recently added.\n\t\t\t// All other advice is FIFO\n\t\t\tvar iterator, advices;\n\n\t\t\tadvices = this.aspects[adviceType];\n\t\t\tif(!advices) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titerator = iterators[adviceType];\n\n\t\t\titerator(this.aspects[adviceType], function(aspect) {\n\t\t\t\tvar advice = aspect.advice;\n\t\t\t\tadvice && advice.apply(context, args);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Invoke all around advice and then the original method\n\t\t *\n\t\t * @param context\n\t\t * @param method\n\t\t * @param args\n\t\t * @param applyOriginal\n\t\t */\n\t\t_callAroundAdvice: function (context, method, args, applyOriginal) {\n\t\t\tvar len, aspects;\n\n\t\t\taspects = this.aspects.around;\n\t\t\tlen = aspects ? aspects.length : 0;\n\n\t\t\t/**\n\t\t\t * Call the next function in the around chain, which will either be another around\n\t\t\t * advice, or the orig method.\n\t\t\t * @param i {Number} index of the around advice\n\t\t\t * @param args {Array} arguments with with to call the next around advice\n\t\t\t */\n\t\t\tfunction callNext(i, args) {\n\t\t\t\t// If we exhausted all aspects, finally call the original\n\t\t\t\t// Otherwise, if we found another around, call it\n\t\t\t\treturn i < 0\n\t\t\t\t\t? applyOriginal(args)\n\t\t\t\t\t: callAround(aspects[i].advice, i, args);\n\t\t\t}\n\n\t\t\tfunction callAround(around, i, args) {\n\t\t\t\tvar proceedCalled, joinpoint;\n\n\t\t\t\tproceedCalled = 0;\n\n\t\t\t\t// Joinpoint is immutable\n\t\t\t\t// TODO: Use Object.freeze once v8 perf problem is fixed\n\t\t\t\tjoinpoint = pushJoinpoint({\n\t\t\t\t\ttarget: context,\n\t\t\t\t\tmethod: method,\n\t\t\t\t\targs: args,\n\t\t\t\t\tproceed: proceedCall,\n\t\t\t\t\tproceedApply: proceedApply,\n\t\t\t\t\tproceedCount: proceedCount\n\t\t\t\t});\n\n\t\t\t\ttry {\n\t\t\t\t\t// Call supplied around advice function\n\t\t\t\t\treturn around.call(context, joinpoint);\n\t\t\t\t} finally {\n\t\t\t\t\tpopJoinpoint();\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * The number of times proceed() has been called\n\t\t\t\t * @return {Number}\n\t\t\t\t */\n\t\t\t\tfunction proceedCount() {\n\t\t\t\t\treturn proceedCalled;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Proceed to the original method/function or the next around\n\t\t\t\t * advice using original arguments or new argument list if\n\t\t\t\t * arguments.length > 0\n\t\t\t\t * @return {*} result of original method/function or next around advice\n\t\t\t\t */\n\t\t\t\tfunction proceedCall(/* newArg1, newArg2... */) {\n\t\t\t\t\treturn proceed(arguments.length > 0 ? slice.call(arguments) : args);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Proceed to the original method/function or the next around\n\t\t\t\t * advice using original arguments or new argument list if\n\t\t\t\t * newArgs is supplied\n\t\t\t\t * @param [newArgs] {Array} new arguments with which to proceed\n\t\t\t\t * @return {*} result of original method/function or next around advice\n\t\t\t\t */\n\t\t\t\tfunction proceedApply(newArgs) {\n\t\t\t\t\treturn proceed(newArgs || args);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Create proceed function that calls the next around advice, or\n\t\t\t\t * the original.  May be called multiple times, for example, in retry\n\t\t\t\t * scenarios\n\t\t\t\t * @param [args] {Array} optional arguments to use instead of the\n\t\t\t\t * original arguments\n\t\t\t\t */\n\t\t\t\tfunction proceed(args) {\n\t\t\t\t\tproceedCalled++;\n\t\t\t\t\treturn callNext(i - 1, args);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn callNext(len - 1, args);\n\t\t},\n\n\t\t/**\n\t\t * Adds the supplied aspect to the advised target method\n\t\t *\n\t\t * @param aspect\n\t\t */\n\t\tadd: function(aspect) {\n\n\t\t\tvar advisor, aspects;\n\n\t\t\tadvisor = this;\n\t\t\taspects = advisor.aspects;\n\n\t\t\tinsertAspect(aspects, aspect);\n\n\t\t\treturn {\n\t\t\t\tremove: function () {\n\t\t\t\t\tvar remaining = removeAspect(aspects, aspect);\n\n\t\t\t\t\t// If there are no aspects left, restore the original method\n\t\t\t\t\tif (!remaining) {\n\t\t\t\t\t\tadvisor.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Removes the Advisor and thus, all aspects from the advised target method, and\n\t\t * restores the original target method, copying back all properties that may have\n\t\t * been added or updated on the advised function.\n\t\t */\n\t\tremove: function () {\n\t\t\tdelete this.advised._advisor;\n\t\t\tthis.target[this.func] = this.orig;\n\t\t}\n\t};\n\n\t/**\n\t * Returns the advisor for the target object-function pair.  A new advisor\n\t * will be created if one does not already exist.\n\t * @param target {*} target containing a method with the supplied methodName\n\t * @param methodName {String} name of method on target for which to get an advisor\n\t * @return {Object|undefined} existing or newly created advisor for the supplied method\n\t */\n\tAdvisor.get = function(target, methodName) {\n\t\tif(!(methodName in target)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar advisor, advised;\n\n\t\tadvised = target[methodName];\n\n\t\tif(typeof advised !== 'function') {\n\t\t\tthrow new Error('Advice can only be applied to functions: ' + methodName);\n\t\t}\n\n\t\tadvisor = advised._advisor;\n\t\tif(!advisor) {\n\t\t\tadvisor = new Advisor(target, methodName);\n\t\t\ttarget[methodName] = advisor.advised;\n\t\t}\n\n\t\treturn advisor;\n\t};\n\n\t/**\n\t * Add an aspect to a pure function, returning an advised version of it.\n\t * NOTE: *only the returned function* is advised.  The original (input) function\n\t * is not modified in any way.\n\t * @param func {Function} function to advise\n\t * @param aspect {Object} aspect to add\n\t * @return {Function} advised function\n\t */\n\tfunction addAspectToFunction(func, aspect) {\n\t\tvar name, placeholderTarget;\n\n\t\tname = func.name || '_';\n\n\t\tplaceholderTarget = {};\n\t\tplaceholderTarget[name] = func;\n\n\t\taddAspectToMethod(placeholderTarget, name, aspect);\n\n\t\treturn placeholderTarget[name];\n\n\t}\n\n\tfunction addAspectToMethod(target, method, aspect) {\n\t\tvar advisor = Advisor.get(target, method);\n\n\t\treturn advisor && advisor.add(aspect);\n\t}\n\n\tfunction addAspectToAll(target, methodArray, aspect) {\n\t\tvar removers, added, f, i;\n\n\t\tremovers = [];\n\t\ti = 0;\n\n\t\twhile((f = methodArray[i++])) {\n\t\t\tadded = addAspectToMethod(target, f, aspect);\n\t\t\tadded && removers.push(added);\n\t\t}\n\n\t\treturn createRemover(removers);\n\t}\n\n\tfunction addAspectToMatches(target, pointcut, aspect) {\n\t\tvar removers = [];\n\t\t// Assume the pointcut is a an object with a .test() method\n\t\tfor (var p in target) {\n\t\t\t// TODO: Decide whether hasOwnProperty is correct here\n\t\t\t// Only apply to own properties that are functions, and match the pointcut regexp\n\t\t\tif (typeof target[p] == 'function' && pointcut.test(p)) {\n\t\t\t\t// if(object.hasOwnProperty(p) && typeof object[p] === 'function' && pointcut.test(p)) {\n\t\t\t\tremovers.push(addAspectToMethod(target, p, aspect));\n\t\t\t}\n\t\t}\n\n\t\treturn createRemover(removers);\n\t}\n\n\tfunction createRemover(removers) {\n\t\treturn {\n\t\t\tremove: function() {\n\t\t\t\tfor (var i = removers.length - 1; i >= 0; --i) {\n\t\t\t\t\tremovers[i].remove();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Create an API function for the specified advice type\n\tfunction adviceApi(type) {\n\t\treturn function(target, method, adviceFunc) {\n\t\t\tvar aspect = {};\n\n\t\t\tif(arguments.length === 2) {\n\t\t\t\taspect[type] = method;\n\t\t\t\treturn meld(target, aspect);\n\t\t\t} else {\n\t\t\t\taspect[type] = adviceFunc;\n\t\t\t\treturn meld(target, method, aspect);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Insert the supplied aspect into aspectList\n\t * @param aspectList {Object} list of aspects, categorized by advice type\n\t * @param aspect {Object} aspect containing one or more supported advice types\n\t */\n\tfunction insertAspect(aspectList, aspect) {\n\t\tvar adviceType, advice, advices;\n\n\t\tfor(adviceType in iterators) {\n\t\t\tadvice = aspect[adviceType];\n\n\t\t\tif(advice) {\n\t\t\t\tadvices = aspectList[adviceType];\n\t\t\t\tif(!advices) {\n\t\t\t\t\taspectList[adviceType] = advices = [];\n\t\t\t\t}\n\n\t\t\t\tadvices.push({\n\t\t\t\t\taspect: aspect,\n\t\t\t\t\tadvice: advice\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove the supplied aspect from aspectList\n\t * @param aspectList {Object} list of aspects, categorized by advice type\n\t * @param aspect {Object} aspect containing one or more supported advice types\n\t * @return {Number} Number of *advices* left on the advised function.  If\n\t *  this returns zero, then it is safe to remove the advisor completely.\n\t */\n\tfunction removeAspect(aspectList, aspect) {\n\t\tvar adviceType, advices, remaining;\n\n\t\tremaining = 0;\n\n\t\tfor(adviceType in iterators) {\n\t\t\tadvices = aspectList[adviceType];\n\t\t\tif(advices) {\n\t\t\t\tremaining += advices.length;\n\n\t\t\t\tfor (var i = advices.length - 1; i >= 0; --i) {\n\t\t\t\t\tif (advices[i].aspect === aspect) {\n\t\t\t\t\t\tadvices.splice(i, 1);\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn remaining;\n\t}\n\n\tfunction applyConstructor(C, instance, args) {\n\t\ttry {\n\t\t\t// Try to define a constructor, but don't care if it fails\n\t\t\tdefineProperty(instance, 'constructor', {\n\t\t\t\tvalue: C,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t} catch(e) {\n\t\t\t// ignore\n\t\t}\n\n\t\tC.apply(instance, args);\n\n\t\treturn instance;\n\t}\n\n\tvar currentJoinpoint, joinpointStack,\n\t\tap, prepend, append, iterators, slice, isArray, defineProperty, objectCreate;\n\n\t// TOOD: Freeze joinpoints when v8 perf problems are resolved\n//\tfreeze = Object.freeze || function (o) { return o; };\n\n\tjoinpointStack = [];\n\n\tap      = Array.prototype;\n\tprepend = ap.unshift;\n\tappend  = ap.push;\n\tslice   = ap.slice;\n\n\tisArray = Array.isArray || function(it) {\n\t\treturn Object.prototype.toString.call(it) == '[object Array]';\n\t};\n\n\t// Check for a *working* Object.defineProperty, fallback to\n\t// simple assignment.\n\tdefineProperty = definePropertyWorks()\n\t\t? Object.defineProperty\n\t\t: function(obj, prop, descriptor) {\n\t\tobj[prop] = descriptor.value;\n\t};\n\n\tobjectCreate = Object.create ||\n\t\t(function() {\n\t\t\tfunction F() {}\n\t\t\treturn function(proto) {\n\t\t\t\tF.prototype = proto;\n\t\t\t\tvar instance = new F();\n\t\t\t\tF.prototype = null;\n\t\t\t\treturn instance;\n\t\t\t};\n\t\t}());\n\n\titerators = {\n\t\t// Before uses reverse iteration\n\t\tbefore: forEachReverse,\n\t\taround: false\n\t};\n\n\t// All other advice types use forward iteration\n\t// Around is a special case that uses recursion rather than\n\t// iteration.  See Advisor._callAroundAdvice\n\titerators.on\n\t\t= iterators.afterReturning\n\t\t= iterators.afterThrowing\n\t\t= iterators.after\n\t\t= forEach;\n\n\tfunction forEach(array, func) {\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tfunc(array[i]);\n\t\t}\n\t}\n\n\tfunction forEachReverse(array, func) {\n\t\tfor (var i = array.length - 1; i >= 0; --i) {\n\t\t\tfunc(array[i]);\n\t\t}\n\t}\n\n\tfunction joinpoint() {\n\t\treturn currentJoinpoint;\n\t}\n\n\tfunction pushJoinpoint(newJoinpoint) {\n\t\tjoinpointStack.push(currentJoinpoint);\n\t\treturn currentJoinpoint = newJoinpoint;\n\t}\n\n\tfunction popJoinpoint() {\n\t\treturn currentJoinpoint = joinpointStack.pop();\n\t}\n\n\tfunction definePropertyWorks() {\n\t\ttry {\n\t\t\treturn 'x' in Object.defineProperty({}, 'x', {});\n\t\t} catch (e) { /* return falsey */ }\n\t}\n\n\treturn meld;\n\n});\n})(typeof define == 'function' && define.amd ? define : function (factory) { module.exports = factory(); }\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/meld/meld.js\n// module id = 0\n// module chunks = 0","// import transceiver from 'transceiver';\nimport meld from 'meld';\n\nconst events = { on: () => {}, emit: () => {} }; // transceiver.channel('events');\nconst components = {};\n\nfunction record(...args) {\n  events.emit('foo', ...args);\n}\n\nfunction evented(targetName) {\n  return (target) => {\n    components[targetName] = target;\n\n    const methodNames = Object.getOwnPropertyNames(target.prototype);\n\n    methodNames.forEach((methodName) => {\n      meld.before(target.prototype, methodName, (...args) => {\n        record(target, targetName, methodName, {\n          ...args\n        });\n      });\n    });\n\n    return class extends target {\n      constructor(...args) {\n        record(target, targetName, {\n          ...args\n        });\n\n        super();\n      }\n    };\n  };\n}\n\nevents.on('foo', (...args) => {\n  console.info(...args);\n});\n\n@evented('TodoList')\nclass TodoList {\n  items = [];\n\n  add(todo) {\n    this.items.push(todo);\n    return todo;\n  }\n\n  count() {\n    return this.items.length;\n  }\n}\n\n@evented('TodoItem')\nclass TodoItem {\n  edit(text) {\n    this.value = text;\n  }\n}\n\n(() => {\n  const todoList = new TodoList();\n  const todo = new TodoItem('Make this demo!');\n\n  todoList.add(todo);\n})();\n\n\n\n// WEBPACK FOOTER //\n// ./src/demo.js","module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-define.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}